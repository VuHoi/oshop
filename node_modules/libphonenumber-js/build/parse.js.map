{"version":3,"sources":["../source/parse.js"],"names":["parse","normalize","replace_characters","is_viable_phone_number","extract_formatted_phone_number","parse_phone_number","parse_phone_number_and_country_phone_code","strip_national_prefix","find_country_code","PLUS_CHARS","VALID_DIGITS","DASHES","SLASHES","DOTS","WHITESPACE","BRACKETS","TILDES","VALID_PUNCTUATION","MIN_LENGTH_PHONE_NUMBER_PATTERN","MIN_LENGTH_FOR_NSN","VALID_PHONE_NUMBER","VALID_PHONE_NUMBER_PATTERN","RegExp","PHONE_NUMBER_START_PATTERN","AFTER_PHONE_NUMBER_END_PATTERN","LEADING_PLUS_CHARS_PATTERN","DIGIT_MAPPINGS","MAX_LENGTH_COUNTRY_CODE","MAX_LENGTH_FOR_NSN","MAX_INPUT_STRING_LENGTH","default_options","country","first_argument","second_argument","third_argument","sort_out_arguments","text","options","metadata","default","countries","Error","restrict","formatted_phone_number","country_phone_code","number","country_metadata","is_international","national_number","did_have_national_prefix","length","national_number_rule","phone","replacements","replaced","character","replacement","toUpperCase","undefined","starts_at","search","slice","replace","test","i","country_phone_code_to_countries","national_prefix_for_parsing","national_prefix_pattern","national_prefix_matcher","exec","national_significant_number","any_groups_were_captured","national_prefix_transform_rule","national_phone_number","possible_countries","country_code","String","restrict_to_country"],"mappings":";;;;;;;;;;;;;;;kBAiNwBA,K;QA2JRC,S,GAAAA,S;QAOAC,kB,GAAAA,kB;QAwBAC,sB,GAAAA,sB;QAMAC,8B,GAAAA,8B;QAwBAC,kB,GAAAA,kB;QA2BAC,yC,GAAAA,yC;QAmDAC,qB,GAAAA,qB;QAuEAC,iB,GAAAA,iB;;AAzjBhB;;AAEA;;AAaA;;AAMA;;;;;;AA1BA;AACA;AACA;AACA;;AAyBO,IAAMC,kCAAa,SAAnB;;AAEP;AACA;AACO,IAAMC,sCAAe,4CAArB;;AAEP;AACA,IAAMC,SAAS,kCAAf;AACA,IAAMC,UAAU,SAAhB;AACA,IAAMC,OAAO,SAAb;AACA,IAAMC,aAAa,6BAAnB;AACA,IAAMC,WAAW,kCAAjB;AACA,IAAMC,SAAS,qBAAf;;AAEA;AACA;AACA;AACA;AACO,IAAMC,qDAAuBN,MAAvB,GAAgCC,OAAhC,GAA0CC,IAA1C,GAAiDC,UAAjD,GAA8DC,QAA9D,GAAyEC,MAA/E;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAME,kCAAkC,MAAMR,YAAN,GAAqB,IAArB,GAA4BS,kBAA5B,GAAiD,GAAzF;AACA;AACA;AACA;AACA;AACA,IAAMC,qBACJ,MAAMX,UAAN,GAAmB,QAAnB,GACA,KADA,GAEC,GAFD,GAEOQ,iBAFP,GAE2B,IAF3B,GAGC,GAHD,GAGOP,YAHP,GAGsB,GAHtB,GAIA,OAJA,GAKA,GALA,GAMCO,iBAND,GAOCP,YAPD,GAQA,IATF;;AAWA;AACA;AACA,IAAMW,6BAA6B,IAAIC,MAAJ;AAElC;AACA,MACCJ,+BADD,GAEA,GAFA,GAGA,GAHA;AAIA;AACA,GALA,GAMCE,kBAND;AAOC;AACA;AACD,GAZkC,EAcnC,GAdmC,CAAnC;;AAgBA;AACA,IAAMG,6BAA6B,IAAID,MAAJ,CAAW,MAAMb,UAAN,GAAmBC,YAAnB,GAAkC,GAA7C,CAAnC;;AAEA;AACA,IAAMc,iCAAiC,IAAIF,MAAJ,CAAW,OAAOZ,YAAP,GAAsB,KAAjC,CAAvC;;AAEA,IAAMe,6BAA6B,IAAIH,MAAJ,CAAW,OAAOb,UAAP,GAAoB,IAA/B,CAAnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,IAAMiB,0CACb;AACC,MAAK,GADN;AAEC,MAAK,GAFN;AAGC,MAAK,GAHN;AAIC,MAAK,GAJN;AAKC,MAAK,GALN;AAMC,MAAK,GANN;AAOC,MAAK,GAPN;AAQC,MAAK,GARN;AASC,MAAK,GATN;AAUC,MAAK,GAVN;AAWC,WAAU,GAXX,EAWgB;AACf,WAAU,GAZX,EAYgB;AACf,WAAU,GAbX,EAagB;AACf,WAAU,GAdX,EAcgB;AACf,WAAU,GAfX,EAegB;AACf,WAAU,GAhBX,EAgBgB;AACf,WAAU,GAjBX,EAiBgB;AACf,WAAU,GAlBX,EAkBgB;AACf,WAAU,GAnBX,EAmBgB;AACf,WAAU,GApBX,EAoBgB;AACf,WAAU,GArBX,EAqBgB;AACf,WAAU,GAtBX,EAsBgB;AACf,WAAU,GAvBX,EAuBgB;AACf,WAAU,GAxBX,EAwBgB;AACf,WAAU,GAzBX,EAyBgB;AACf,WAAU,GA1BX,EA0BgB;AACf,WAAU,GA3BX,EA2BgB;AACf,WAAU,GA5BX,EA4BgB;AACf,WAAU,GA7BX,EA6BgB;AACf,WAAU,GA9BX,EA8BgB;AACf,WAAU,GA/BX,EA+BgB;AACf,WAAU,GAhCX,EAgCgB;AACf,WAAU,GAjCX,EAiCgB;AACf,WAAU,GAlCX,EAkCgB;AACf,WAAU,GAnCX,EAmCgB;AACf,WAAU,GApCX,EAoCgB;AACf,WAAU,GArCX,EAqCgB;AACf,WAAU,GAtCX,EAsCgB;AACf,WAAU,GAvCX,EAuCgB;AACf,WAAU,GAxCX,CAwCgB;;;AAGhB;AA3CA,CADO,CA6CP,IAAMC,0BAA0B,CAAhC;;AAEA;AACA,IAAMR,qBAAqB,CAA3B;;AAEA;AACA;AACA,IAAMS,qBAAqB,EAA3B;;AAEA;AACA;AACA,IAAMC,0BAA0B,GAAhC;;AAEA,IAAMC,kBACN;AACCC,UAAS;;AAGV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7BA,CADA,CA+Be,SAAS/B,KAAT,CAAegC,cAAf,EAA+BC,eAA/B,EAAgDC,cAAhD,EACf;AAAA,2BACmCC,mBAAmBH,cAAnB,EAAmCC,eAAnC,EAAoDC,cAApD,CADnC;AAAA,KACOE,IADP,uBACOA,IADP;AAAA,KACaC,OADb,uBACaA,OADb;AAAA,KACsBC,QADtB,uBACsBA,QADtB;;AAGC,KAAI,CAACD,OAAL,EACA;AACCA,uCAAeP,eAAf;AACA;;AAED;;AAEA;AACA,KAAIO,QAAQN,OAAR,CAAgBQ,OAAhB,IAA2B,CAACD,SAASE,SAAT,CAAmBH,QAAQN,OAAR,CAAgBQ,OAAnC,CAAhC,EACA;AACC,QAAM,IAAIE,KAAJ,4BAAmCJ,QAAQN,OAAR,CAAgBQ,OAAnD,CAAN;AACA;;AAED;AACA,KAAIF,QAAQN,OAAR,CAAgBW,QAAhB,IAA4B,CAACJ,SAASE,SAAT,CAAmBH,QAAQN,OAAR,CAAgBW,QAAnC,CAAjC,EACA;AACC,QAAM,IAAID,KAAJ,4BAAmCJ,QAAQN,OAAR,CAAgBW,QAAnD,CAAN;AACA;;AAED;;AAEA,KAAMC,yBAAyBvC,+BAA+BgC,IAA/B,CAA/B;;AAEA;AACA,KAAI,CAACjC,uBAAuBwC,sBAAvB,CAAL,EACA;AACC,SAAO,EAAP;AACA;;AA9BF,6BAgCsCrC,0CAA0CqC,sBAA1C,EAAkEL,QAAlE,CAhCtC;AAAA,KAgCOM,kBAhCP,yBAgCOA,kBAhCP;AAAA,KAgC2BC,MAhC3B,yBAgC2BA,MAhC3B;;AAkCC;;;AACA,KAAI,CAACA,MAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED,KAAId,gBAAJ;AACA,KAAIe,yBAAJ;;AAEA;AACA,KAAIC,mBAAmB,KAAvB;;AAEA,KAAIH,kBAAJ,EACA;AACCG,qBAAmB,IAAnB;;AAEA;AACA,MAAIV,QAAQN,OAAR,CAAgBW,QAAhB,IACHE,uBAAuB,8BAAeN,SAASE,SAAT,CAAmBH,QAAQN,OAAR,CAAgBW,QAAnC,CAAf,CADxB,EAEA;AACC,UAAO,EAAP;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACAI,qBAAmB,kDAAmCF,kBAAnC,EAAuDN,QAAvD,CAAnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAzBD,MA0BK,IAAID,QAAQN,OAAR,CAAgBW,QAAhB,IAA4BL,QAAQN,OAAR,CAAgBQ,OAAhD,EACL;AACCR,YAAUM,QAAQN,OAAR,CAAgBW,QAAhB,IAA4BL,QAAQN,OAAR,CAAgBQ,OAAtD;AACAO,qBAAmBR,SAASE,SAAT,CAAmBT,OAAnB,CAAnB;;AAEAc,WAAS5C,UAAUmC,IAAV,CAAT;AACA;;AAED,KAAI,CAACU,gBAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED,KAAME,kBAAkBzC,sBAAsBsC,MAAtB,EAA8BC,gBAA9B,CAAxB;;AAEA,KAAMG,2BAA2BD,oBAAoBH,MAArD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,CAACd,OAAL,EACA;AACC;AACA;AACA;AACAA,YAAUvB,kBAAkBoC,kBAAlB,EAAsCI,eAAtC,EAAuDV,QAAvD,CAAV;;AAEA;AACA;AACA;AACA,MAAI,CAACP,OAAL,EACA;AACC,UAAO,EAAP;AACA;;AAED;AACAe,qBAAmBR,SAASE,SAAT,CAAmBT,OAAnB,CAAnB;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAIiB,gBAAgBE,MAAhB,GAAyBtB,kBAA7B,EACA;AACC,SAAO,EAAP;AACA;;AAED;AACA;AACA,KAAMuB,uBAAuB,IAAI7B,MAAJ,CAAW,2CAA4BwB,gBAA5B,CAAX,CAA7B;;AAEA;AACA,KAAI,CAAC,8BAAiBE,eAAjB,EAAkCG,oBAAlC,CAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED,QAAO,EAAEpB,gBAAF,EAAWqB,OAAOJ,eAAlB,EAAP;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACO,SAAS/C,SAAT,CAAmB4C,MAAnB,EACP;AACC,QAAO3C,mBAAmB2C,MAAnB,EAA2BnB,cAA3B,CAAP;AACA;;AAED;AACA;AACO,SAASxB,kBAAT,CAA4BkC,IAA5B,EAAkCiB,YAAlC,EACP;AACC,KAAIC,WAAW,EAAf;;AADD;AAAA;AAAA;;AAAA;AAGC,kDAAsBlB,IAAtB,4GACA;AAAA,OADSmB,SACT;;AACC,OAAMC,cAAcH,aAAaE,UAAUE,WAAV,EAAb,CAApB;;AAEA,OAAID,gBAAgBE,SAApB,EACA;AACCJ,gBAAYE,WAAZ;AACA;AACD;AAXF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAaC,QAAOF,QAAP;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASnD,sBAAT,CAAgC0C,MAAhC,EACP;AACC,QAAOA,OAAOK,MAAP,IAAiB/B,kBAAjB,IACN,8BAAiB0B,MAAjB,EAAyBxB,0BAAzB,CADD;AAEA;;AAEM,SAASjB,8BAAT,CAAwCgC,IAAxC,EACP;AACC,KAAI,CAACA,IAAD,IAASA,KAAKc,MAAL,GAAcrB,uBAA3B,EACA;AACC,SAAO,EAAP;AACA;;AAED;;AAEA,KAAM8B,YAAYvB,KAAKwB,MAAL,CAAYrC,0BAAZ,CAAlB;;AAEA,KAAIoC,YAAY,CAAhB,EACA;AACC,SAAO,EAAP;AACA;;AAED,QAAOvB;AACN;AADM,EAELyB,KAFK,CAECF,SAFD;AAGN;AAHM,EAILG,OAJK,CAIGtC,8BAJH,EAImC,EAJnC,CAAP;AAKA;;AAED;AACO,SAASnB,kBAAT,CAA4BwC,MAA5B,EACP;AACC,KAAI,CAACA,MAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED,KAAME,mBAAmBtB,2BAA2BsC,IAA3B,CAAgClB,MAAhC,CAAzB;;AAEA;AACA;AACAA,UAAS5C,UAAU4C,MAAV,CAAT;;AAEA,KAAIE,gBAAJ,EACA;AACC,eAAWF,MAAX;AACA;;AAED,QAAOA,MAAP;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACO,SAASvC,yCAAT,CAAmDuC,MAAnD,EAA2DP,QAA3D,EACP;AACCO,UAASxC,mBAAmBwC,MAAnB,CAAT;;AAEA,KAAI,CAACA,MAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED;AACA;AACA,KAAIA,OAAO,CAAP,MAAc,GAAlB,EACA;AACC,SAAO,EAAEA,cAAF,EAAP;AACA;;AAED;AACAA,UAASA,OAAOgB,KAAP,CAAa,CAAb,CAAT;;AAEA;AACA,KAAIhB,OAAO,CAAP,MAAc,GAAlB,EACA;AACC,SAAO,EAAP;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAImB,IAAI,CAAR;AACA,QAAOA,KAAKrC,uBAAL,IAAgCqC,KAAKnB,OAAOK,MAAnD,EACA;AACC,MAAMN,qBAAqBC,OAAOgB,KAAP,CAAa,CAAb,EAAgBG,CAAhB,CAA3B;;AAEA,MAAI1B,SAAS2B,+BAAT,CAAyCrB,kBAAzC,CAAJ,EACA;AACC,UAAO,EAAEA,sCAAF,EAAsBC,QAAQA,OAAOgB,KAAP,CAAaG,CAAb,CAA9B,EAAP;AACA;;AAEDA;AACA;;AAED,QAAO,EAAP;AACA;;AAED;AACO,SAASzD,qBAAT,CAA+BsC,MAA/B,EAAuCC,gBAAvC,EACP;AACC,KAAMoB,8BAA8B,+CAAgCpB,gBAAhC,CAApC;;AAEA,KAAI,CAACD,MAAD,IAAW,CAACqB,2BAAhB,EACA;AACC,SAAOrB,MAAP;AACA;;AAED;AACA,KAAMsB,0BAA0B,IAAI7C,MAAJ,CAAW,SAAS4C,2BAAT,GAAuC,GAAlD,CAAhC;AACA,KAAME,0BAA0BD,wBAAwBE,IAAxB,CAA6BxB,MAA7B,CAAhC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,CAACuB,uBAAL,EACA;AACC,SAAOvB,MAAP;AACA;;AAGD,KAAIyB,oCAAJ;;AAEA;AACA;AACA,KAAMC,2BAA2BH,wBAAwBA,wBAAwBlB,MAAxB,GAAiC,CAAzD,CAAjC;AACA,KAAMsB,iCAAiC,kDAAmC1B,gBAAnC,CAAvC;;AAEA;AACA,KAAI0B,kCAAkCD,wBAAtC,EACA;AACCD,gCAA8BzB,OAAOiB,OAAP,CAAeK,uBAAf,EAAwCK,8BAAxC,CAA9B;AACA;AACD;AACA;AALA,MAOA;AACCF,iCAA8BzB,OAAOgB,KAAP,CAAaO,wBAAwB,CAAxB,EAA2BlB,MAAxC,CAA9B;AACA;;AAED;AACA,KAAMC,uBAAuB,IAAI7B,MAAJ,CAAW,2CAA4BwB,gBAA5B,CAAX,CAA7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,8BAAiBD,MAAjB,EAAyBM,oBAAzB,KACF,CAAC,8BAAiBmB,2BAAjB,EAA8CnB,oBAA9C,CADH,EAEA;AACC,SAAON,MAAP;AACA;;AAED;AACE,QAAOyB,2BAAP;AACF;;AAEM,SAAS9D,iBAAT,CAA2BoC,kBAA3B,EAA+C6B,qBAA/C,EAAsEnC,QAAtE,EACP;AACC;AACA,KAAMoC,qBAAqBpC,SAAS2B,+BAAT,CAAyCrB,kBAAzC,CAA3B;;AAEA;AACA;AACA,KAAI8B,mBAAmBxB,MAAnB,KAA8B,CAAlC,EACA;AACC,SAAOwB,mBAAmB,CAAnB,CAAP;AACA;;AATF;AAAA;AAAA;;AAAA;AAWC,mDAAyBA,kBAAzB,iHACA;AAAA,OADSC,YACT;;AACC,OAAM5C,UAAUO,SAASE,SAAT,CAAmBmC,YAAnB,CAAhB;;AAEA;AACA,OAAI,kCAAmB5C,OAAnB,CAAJ,EACA;AACC,QAAI0C,yBACHA,sBAAsBb,MAAtB,CAA6B,kCAAmB7B,OAAnB,CAA7B,MAA8D,CAD/D,EAEA;AACC,YAAO4C,YAAP;AACA;AACD;AACD;AACA;AATA,QAUK,IAAI,6BAAgB,EAAEvB,OAAOqB,qBAAT,EAAgC1C,SAAS4C,YAAzC,EAAhB,EAAyErC,QAAzE,CAAJ,EACL;AACC,YAAOqC,YAAP;AACA;AACD;AA9BF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+BC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAASxC,kBAAT,CAA4BH,cAA5B,EAA4CC,eAA5C,EAA6DC,cAA7D,EACA;AACC,KAAIE,aAAJ;AACA,KAAIC,gBAAJ;AACA,KAAIC,iBAAJ;;AAEA;AACA;AACA,KAAI,OAAON,cAAP,KAA0B,QAA9B,EACA;AACCA,mBAAiB4C,OAAO5C,cAAP,CAAjB;AACA;;AAED,KAAI,OAAOA,cAAP,KAA0B,QAA9B,EACA;AACCI,SAAOJ,cAAP;AACA;;AAED;AACA,KAAI,OAAOC,eAAP,KAA2B,QAA/B,EACA;AACC,MAAM4C,sBAAsB5C,eAA5B;;AAEAI,uCAEIP,eAFJ;;AAICC,YACA;AACCW,cAAUmC;AADX;AALD;;AAUAvC,aAAWJ,cAAX;AACA,EAfD,MAiBA;AACC;AACA,MAAID,mBAAmBA,gBAAgBO,SAAvC,EACA;AACCF,cAAWL,eAAX;AACA,GAHD,MAKA;AACCI,aAAWJ,eAAX;AACAK,cAAWJ,cAAX;AACA;AACD;;AAED;AACA,KAAI,CAACI,QAAL,EACA;AACC,QAAM,IAAIG,KAAJ,CAAU,qBAAV,CAAN;AACA;;AAED,QAAO,EAAEL,UAAF,EAAQC,gBAAR,EAAiBC,kBAAjB,EAAP;AACA","file":"parse.js","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of 17th November, 2016.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport { matches_entirely } from './common'\r\n\r\nimport\r\n{\r\n\tget_phone_code,\r\n\tget_national_number_pattern,\r\n\tget_national_prefix_for_parsing,\r\n\tget_national_prefix_transform_rule,\r\n\tget_leading_digits,\r\n\tget_metadata_by_country_phone_code,\r\n\tget_formats,\r\n\t// get_format_national_prefix_is_mandatory_when_formatting\r\n}\r\nfrom './metadata'\r\n\r\nimport\r\n{\r\n\tchoose_format_for_number\r\n}\r\nfrom './format'\r\n\r\nimport get_number_type from './get number type'\r\n\r\nexport const PLUS_CHARS = '+\\uFF0B'\r\n\r\n// Digits accepted in phone numbers\r\n// (ascii, fullwidth, arabic-indic, and eastern arabic digits).\r\nexport const VALID_DIGITS = '0-9\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9'\r\n\r\n// `DASHES` will be right after the opening square bracket of the \"character class\"\r\nconst DASHES = '-\\u2010-\\u2015\\u2212\\u30FC\\uFF0D'\r\nconst SLASHES = '\\uFF0F/'\r\nconst DOTS = '\\uFF0E.'\r\nconst WHITESPACE = ' \\u00A0\\u00AD\\u200B\\u2060\\u3000'\r\nconst BRACKETS = '()\\uFF08\\uFF09\\uFF3B\\uFF3D\\\\[\\\\]'\r\nconst TILDES = '~\\u2053\\u223C\\uFF5E'\r\n\r\n// Regular expression of acceptable punctuation found in phone numbers. This\r\n// excludes punctuation found as a leading character only. This consists of dash\r\n// characters, white space characters, full stops, slashes, square brackets,\r\n// parentheses and tildes. Full-width variants are also present.\r\nexport const VALID_PUNCTUATION = `${DASHES}${SLASHES}${DOTS}${WHITESPACE}${BRACKETS}${TILDES}`\r\n\r\n//  Regular expression of viable phone numbers. This is location independent.\r\n//  Checks we have at least three leading digits, and only valid punctuation,\r\n//  alpha characters and digits in the phone number. Does not include extension\r\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\r\n//  used as a placeholder for carrier codes, for example in Brazilian phone\r\n//  numbers. We also allow multiple '+' characters at the start.\r\n//\r\n//  Corresponds to the following:\r\n//  [digits]{minLengthNsn}|\r\n//  plus_sign*\r\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\r\n//\r\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\r\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\r\n//  The second expression restricts the number of digits to three or more, but\r\n//  then allows them to be in international form, and to have alpha-characters\r\n//  and punctuation. We split up the two reg-exes here and combine them when\r\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\r\n//  with ^ and append $ to each branch.\r\n//\r\n//  \"Note VALID_PUNCTUATION starts with a -,\r\n//   so must be the first in the range\" (c) Google devs.\r\n//  (wtf did they mean by saying that; probably nothing)\r\n//\r\nconst MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'\r\n//\r\n// And this is the second reg-exp:\r\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\r\n//\r\nconst VALID_PHONE_NUMBER =\r\n\t\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t\t'(?:' +\r\n\t\t\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t\t\t'[' + VALID_DIGITS + ']' +\r\n\t\t'){3,}' +\r\n\t\t'[' +\r\n\t\t\tVALID_PUNCTUATION +\r\n\t\t\tVALID_DIGITS +\r\n\t\t']*'\r\n\r\n// The combined regular expression for valid phone numbers:\r\n//\r\nconst VALID_PHONE_NUMBER_PATTERN = new RegExp\r\n(\r\n\t// Either a short two-digit-only phone number\r\n\t'^' +\r\n\t\tMIN_LENGTH_PHONE_NUMBER_PATTERN +\r\n\t'$' +\r\n\t'|' +\r\n\t// Or a longer fully parsed phone number (min 3 characters)\r\n\t'^' +\r\n\t\tVALID_PHONE_NUMBER +\r\n\t\t// screw phone number extensions\r\n\t\t// '(?:' + EXTN_PATTERNS_FOR_PARSING + ')?' +\r\n\t'$'\r\n,\r\n'i')\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$')\r\n\r\nconst LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')\r\n\r\n// These mappings map a character (key) to a specific digit that should\r\n// replace it for normalization purposes. Non-European digits that\r\n// may be used in phone numbers are mapped to a European equivalent.\r\n//\r\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\r\n//\r\nexport const DIGIT_MAPPINGS =\r\n{\r\n\t'0': '0',\r\n\t'1': '1',\r\n\t'2': '2',\r\n\t'3': '3',\r\n\t'4': '4',\r\n\t'5': '5',\r\n\t'6': '6',\r\n\t'7': '7',\r\n\t'8': '8',\r\n\t'9': '9',\r\n\t'\\uFF10': '0', // Fullwidth digit 0\r\n\t'\\uFF11': '1', // Fullwidth digit 1\r\n\t'\\uFF12': '2', // Fullwidth digit 2\r\n\t'\\uFF13': '3', // Fullwidth digit 3\r\n\t'\\uFF14': '4', // Fullwidth digit 4\r\n\t'\\uFF15': '5', // Fullwidth digit 5\r\n\t'\\uFF16': '6', // Fullwidth digit 6\r\n\t'\\uFF17': '7', // Fullwidth digit 7\r\n\t'\\uFF18': '8', // Fullwidth digit 8\r\n\t'\\uFF19': '9', // Fullwidth digit 9\r\n\t'\\u0660': '0', // Arabic-indic digit 0\r\n\t'\\u0661': '1', // Arabic-indic digit 1\r\n\t'\\u0662': '2', // Arabic-indic digit 2\r\n\t'\\u0663': '3', // Arabic-indic digit 3\r\n\t'\\u0664': '4', // Arabic-indic digit 4\r\n\t'\\u0665': '5', // Arabic-indic digit 5\r\n\t'\\u0666': '6', // Arabic-indic digit 6\r\n\t'\\u0667': '7', // Arabic-indic digit 7\r\n\t'\\u0668': '8', // Arabic-indic digit 8\r\n\t'\\u0669': '9', // Arabic-indic digit 9\r\n\t'\\u06F0': '0', // Eastern-Arabic digit 0\r\n\t'\\u06F1': '1', // Eastern-Arabic digit 1\r\n\t'\\u06F2': '2', // Eastern-Arabic digit 2\r\n\t'\\u06F3': '3', // Eastern-Arabic digit 3\r\n\t'\\u06F4': '4', // Eastern-Arabic digit 4\r\n\t'\\u06F5': '5', // Eastern-Arabic digit 5\r\n\t'\\u06F6': '6', // Eastern-Arabic digit 6\r\n\t'\\u06F7': '7', // Eastern-Arabic digit 7\r\n\t'\\u06F8': '8', // Eastern-Arabic digit 8\r\n\t'\\u06F9': '9'  // Eastern-Arabic digit 9\r\n}\r\n\r\n// The maximum length of the country calling code.\r\nconst MAX_LENGTH_COUNTRY_CODE = 3\r\n\r\n// The minimum length of the national significant number.\r\nconst MIN_LENGTH_FOR_NSN = 2\r\n\r\n// The ITU says the maximum length should be 15,\r\n// but one can find longer numbers in Germany.\r\nconst MAX_LENGTH_FOR_NSN = 17\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\nconst default_options =\r\n{\r\n\tcountry: {}\r\n}\r\n\r\n// `options`:\r\n//  {\r\n//    country:\r\n//    {\r\n//      restrict - (a two-letter country code)\r\n//                 the phone number must be in this country\r\n//\r\n//      default - (a two-letter country code)\r\n//                default country to use for phone number parsing and validation\r\n//                (if no country code could be derived from the phone number)\r\n//    }\r\n//  }\r\n//\r\n// Returns `{ country, number }`\r\n//\r\n// Example use cases:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\nexport default function parse(first_argument, second_argument, third_argument)\r\n{\r\n\tlet { text, options, metadata } = sort_out_arguments(first_argument, second_argument, third_argument)\r\n\r\n\tif (!options)\r\n\t{\r\n\t\toptions = { ...default_options }\r\n\t}\r\n\r\n\t// Validate country codes\r\n\r\n\t// Validate `default` country\r\n\tif (options.country.default && !metadata.countries[options.country.default])\r\n\t{\r\n\t\tthrow new Error(`Unknown country code: ${options.country.default}`)\r\n\t}\r\n\r\n\t// Validate `restrict` country\r\n\tif (options.country.restrict && !metadata.countries[options.country.restrict])\r\n\t{\r\n\t\tthrow new Error(`Unknown country code: ${options.country.restrict}`)\r\n\t}\r\n\r\n\t// Parse the phone number\r\n\r\n\tconst formatted_phone_number = extract_formatted_phone_number(text)\r\n\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!is_viable_phone_number(formatted_phone_number))\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tlet { country_phone_code, number } = parse_phone_number_and_country_phone_code(formatted_phone_number, metadata)\r\n\r\n\t// Maybe invalid country phone code encountered\r\n\tif (!number)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tlet country\r\n\tlet country_metadata\r\n\r\n\t// Whether the phone number is formatted as an international phone number\r\n\tlet is_international = false\r\n\r\n\tif (country_phone_code)\r\n\t{\r\n\t\tis_international = true\r\n\r\n\t\t// Check country restriction\r\n\t\tif (options.country.restrict &&\r\n\t\t\tcountry_phone_code !== get_phone_code(metadata.countries[options.country.restrict]))\r\n\t\t{\r\n\t\t\treturn {}\r\n\t\t}\r\n\r\n\t\t// Formatting information for regions which share\r\n\t\t// a country calling code is contained by only one region\r\n\t\t// for performance reasons. For example, for NANPA region\r\n\t\t// (\"North American Numbering Plan Administration\",\r\n\t\t//  which includes USA, Canada, Cayman Islands, Bahamas, etc)\r\n\t\t// it will be contained in the metadata for `US`.\r\n\t\tcountry_metadata = get_metadata_by_country_phone_code(country_phone_code, metadata)\r\n\r\n\t\t// `country` will be set later,\r\n\t\t// because, for example, for NANPA countries\r\n\t\t// there are several countries corresponding\r\n\t\t// to the same `1` country phone code.\r\n\t\t// Therefore, to reliably determine the exact country,\r\n\t\t// national (significant) number should be parsed first.\r\n\t}\r\n\telse if (options.country.restrict || options.country.default)\r\n\t{\r\n\t\tcountry = options.country.restrict || options.country.default\r\n\t\tcountry_metadata = metadata.countries[country]\r\n\r\n\t\tnumber = normalize(text)\r\n\t}\r\n\r\n\tif (!country_metadata)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst national_number = strip_national_prefix(number, country_metadata)\r\n\r\n\tconst did_have_national_prefix = national_number !== number\r\n\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/67\r\n\t// if (!is_international && !did_have_national_prefix &&\r\n\t// \t\tis_national_prefix_required(national_number, country_metadata))\r\n\t// {\r\n\t// \treturn {}\r\n\t// }\r\n\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\tif (!country)\r\n\t{\r\n\t\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t\t// get their countries populated with the full set of\r\n\t\t// \"phone number type\" regular expressions.\r\n\t\tcountry = find_country_code(country_phone_code, national_number, metadata)\r\n\r\n\t\t// Just in case there appears to be a bug in Google's metadata\r\n\t\t// and the exact country could not be extracted from the phone number.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (!country)\r\n\t\t{\r\n\t\t\treturn {}\r\n\t\t}\r\n\r\n\t\t// Update metadata to be for this specific country\r\n\t\tcountry_metadata = metadata.countries[country]\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (national_number.length > MAX_LENGTH_FOR_NSN)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst national_number_rule = new RegExp(get_national_number_pattern(country_metadata))\r\n\r\n\t// Check if national phone number pattern matches the number\r\n\tif (!matches_entirely(national_number, national_number_rule))\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\treturn { country, phone: national_number }\r\n}\r\n\r\n// Normalizes a string of characters representing a phone number.\r\n// This converts wide-ascii and arabic-indic numerals to European numerals,\r\n// and strips punctuation and alpha characters.\r\n//\r\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\r\n//\r\nexport function normalize(number)\r\n{\r\n\treturn replace_characters(number, DIGIT_MAPPINGS)\r\n}\r\n\r\n// For any character not being part of `replacements`\r\n// it is removed from the phone number.\r\nexport function replace_characters(text, replacements)\r\n{\r\n\tlet replaced = ''\r\n\r\n\tfor (let character of text)\r\n\t{\r\n\t\tconst replacement = replacements[character.toUpperCase()]\r\n\r\n\t\tif (replacement !== undefined)\r\n\t\t{\r\n\t\t\treplaced += replacement\r\n\t\t}\r\n\t}\r\n\r\n\treturn replaced\r\n}\r\n\r\n// Checks to see if the string of characters could possibly be a phone number at\r\n// all. At the moment, checks to see that the string begins with at least 2\r\n// digits, ignoring any punctuation commonly found in phone numbers. This method\r\n// does not require the number to be normalized in advance - but does assume\r\n// that leading non-number symbols have been removed, such as by the method\r\n// `extract_possible_number`.\r\n//\r\nexport function is_viable_phone_number(number)\r\n{\r\n\treturn number.length >= MIN_LENGTH_FOR_NSN &&\r\n\t\tmatches_entirely(number, VALID_PHONE_NUMBER_PATTERN)\r\n}\r\n\r\nexport function extract_formatted_phone_number(text)\r\n{\r\n\tif (!text || text.length > MAX_INPUT_STRING_LENGTH)\r\n\t{\r\n\t\treturn ''\r\n\t}\r\n\r\n\t// Attempt to extract a possible number from the string passed in\r\n\r\n\tconst starts_at = text.search(PHONE_NUMBER_START_PATTERN)\r\n\r\n\tif (starts_at < 0)\r\n\t{\r\n\t\treturn ''\r\n\t}\r\n\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(starts_at)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n// Parses a formatted phone number.\r\nexport function parse_phone_number(number)\r\n{\r\n\tif (!number)\r\n\t{\r\n\t\treturn ''\r\n\t}\r\n\r\n\tconst is_international = LEADING_PLUS_CHARS_PATTERN.test(number)\r\n\r\n\t// Remove non-digits\r\n\t// (and strip the possible leading '+')\r\n\tnumber = normalize(number)\r\n\r\n\tif (is_international)\r\n\t{\r\n\t\treturn `+${number}`\r\n\t}\r\n\r\n\treturn number\r\n}\r\n\r\n// Parses a formatted phone number\r\n// and returns `{ country_phone_code, number }`\r\n// where `number` is the national (significant) phone number.\r\n//\r\n// (aka `maybeExtractCountryPhoneCode`)\r\n//\r\nexport function parse_phone_number_and_country_phone_code(number, metadata)\r\n{\r\n\tnumber = parse_phone_number(number)\r\n\r\n\tif (!number)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If this is not an international phone number,\r\n\t// then don't extract country phone code.\r\n\tif (number[0] !== '+')\r\n\t{\r\n\t\treturn { number }\r\n\t}\r\n\r\n\t// Strip the leading '+' sign\r\n\tnumber = number.slice(1)\r\n\r\n\t// Fast abortion: country codes do not begin with a '0'\r\n\tif (number[0] === '0')\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// The thing with country phone codes\r\n\t// is that they are orthogonal to each other\r\n\t// i.e. there's no such country phone code A\r\n\t// for which country phone code B exists\r\n\t// where B starts with A.\r\n\t// Therefore, while scanning digits,\r\n\t// if a valid country code is found,\r\n\t// that means that it is the country code.\r\n\t//\r\n\tlet i = 1\r\n\twhile (i <= MAX_LENGTH_COUNTRY_CODE && i <= number.length)\r\n\t{\r\n\t\tconst country_phone_code = number.slice(0, i)\r\n\r\n\t\tif (metadata.country_phone_code_to_countries[country_phone_code])\r\n\t\t{\r\n\t\t\treturn { country_phone_code, number: number.slice(i) }\r\n\t\t}\r\n\r\n\t\ti++\r\n\t}\r\n\r\n\treturn {}\r\n}\r\n\r\n// Strips any national prefix (such as 0, 1) present in the number provided\r\nexport function strip_national_prefix(number, country_metadata)\r\n{\r\n\tconst national_prefix_for_parsing = get_national_prefix_for_parsing(country_metadata)\r\n\r\n\tif (!number || !national_prefix_for_parsing)\r\n\t{\r\n\t\treturn number\r\n\t}\r\n\r\n\t// Attempt to parse the first digits as a national prefix\r\n\tconst national_prefix_pattern = new RegExp('^(?:' + national_prefix_for_parsing + ')')\r\n\tconst national_prefix_matcher = national_prefix_pattern.exec(number)\r\n\r\n\t// If no national prefix is present in the phone number,\r\n\t// but if the national prefix is optional for this country,\r\n\t// then consider this phone number valid.\r\n\t//\r\n\t// Google's reference `libphonenumber` implementation\r\n\t// wouldn't recognize such phone numbers as valid,\r\n\t// but I think it would perfectly make sense\r\n\t// to consider such phone numbers as valid\r\n\t// because if a national phone number was originally\r\n\t// formatted without the national prefix\r\n\t// then it must be parseable back into the original national number.\r\n\t// In other words, `parse(format(number))`\r\n\t// must always be equal to `number`.\r\n\t//\r\n\tif (!national_prefix_matcher)\r\n\t{\r\n\t\treturn number\r\n\t}\r\n\r\n\r\n\tlet national_significant_number\r\n\r\n\t// `national_prefix_for_parsing` capturing groups\r\n\t// (used only for really messy cases: Argentina, Brazil, Mexico, Somalia)\r\n\tconst any_groups_were_captured = national_prefix_matcher[national_prefix_matcher.length - 1]\r\n\tconst national_prefix_transform_rule = get_national_prefix_transform_rule(country_metadata)\r\n\r\n\t// If the national number tranformation is needed then do it\r\n\tif (national_prefix_transform_rule && any_groups_were_captured)\r\n\t{\r\n\t\tnational_significant_number = number.replace(national_prefix_pattern, national_prefix_transform_rule)\r\n\t}\r\n\t// Else, no transformation is necessary,\r\n\t// and just strip the national prefix.\r\n\telse\r\n\t{\r\n\t\tnational_significant_number = number.slice(national_prefix_matcher[0].length)\r\n\t}\r\n\r\n\t// Verify the parsed national (significant) number for this country\r\n\tconst national_number_rule = new RegExp(get_national_number_pattern(country_metadata))\r\n\r\n\t// If the original number (before stripping national prefix) was viable,\r\n\t// and the resultant number is not, then prefer the original phone number.\r\n\t// This is because for some countries (e.g. Russia) the same digit could be both\r\n\t// a national prefix and a leading digit of a valid national phone number,\r\n\t// like `8` is the national prefix for Russia and both\r\n\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\tif (matches_entirely(number, national_number_rule) &&\r\n\t\t\t!matches_entirely(national_significant_number, national_number_rule))\r\n\t{\r\n\t\treturn number\r\n\t}\r\n\r\n\t// Return the parsed national (significant) number\r\n   return national_significant_number\r\n}\r\n\r\nexport function find_country_code(country_phone_code, national_phone_number, metadata)\r\n{\r\n\t// Is always non-empty, because `country_phone_code` is always valid\r\n\tconst possible_countries = metadata.country_phone_code_to_countries[country_phone_code]\r\n\r\n\t// If there's just one country corresponding to the country code,\r\n\t// then just return it, without further phone number digits validation.\r\n\tif (possible_countries.length === 1)\r\n\t{\r\n\t\treturn possible_countries[0]\r\n\t}\r\n\r\n\tfor (let country_code of possible_countries)\r\n\t{\r\n\t\tconst country = metadata.countries[country_code]\r\n\r\n\t\t// Leading digits check would be the simplest one\r\n\t\tif (get_leading_digits(country))\r\n\t\t{\r\n\t\t\tif (national_phone_number &&\r\n\t\t\t\tnational_phone_number.search(get_leading_digits(country)) === 0)\r\n\t\t\t{\r\n\t\t\t\treturn country_code\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Else perform full validation with all of those bulky\r\n\t\t// fixed-line/mobile/etc regular expressions.\r\n\t\telse if (get_number_type({ phone: national_phone_number, country: country_code }, metadata))\r\n\t\t{\r\n\t\t\treturn country_code\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// export function is_national_prefix_required(national_number, country_metadata)\r\n// {\r\n// \tconst format = choose_format_for_number(get_formats(country_metadata), national_number)\r\n//\r\n// \tif (format)\r\n// \t{\r\n// \t\treturn get_format_national_prefix_is_mandatory_when_formatting(format, country_metadata)\r\n// \t}\r\n// }\r\n\r\n// Sort out arguments\r\nfunction sort_out_arguments(first_argument, second_argument, third_argument)\r\n{\r\n\tlet text\r\n\tlet options\r\n\tlet metadata\r\n\r\n\t// Normalize numerical `value`.\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/142\r\n\tif (typeof first_argument === 'number')\r\n\t{\r\n\t\tfirst_argument = String(first_argument)\r\n\t}\r\n\r\n\tif (typeof first_argument === 'string')\r\n\t{\r\n\t\ttext = first_argument\r\n\t}\r\n\r\n\t// Covert `resrict` country to an `options` object\r\n\tif (typeof second_argument === 'string')\r\n\t{\r\n\t\tconst restrict_to_country = second_argument\r\n\r\n\t\toptions =\r\n\t\t{\r\n\t\t\t...default_options,\r\n\r\n\t\t\tcountry:\r\n\t\t\t{\r\n\t\t\t\trestrict: restrict_to_country\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmetadata = third_argument\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Differentiate `metadata` from `options`\r\n\t\tif (second_argument && second_argument.countries)\r\n\t\t{\r\n\t\t\tmetadata = second_argument\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\toptions  = second_argument\r\n\t\t\tmetadata = third_argument\r\n\t\t}\r\n\t}\r\n\r\n\t// Sanity check\r\n\tif (!metadata)\r\n\t{\r\n\t\tthrow new Error('Metadata not passed')\r\n\t}\r\n\r\n\treturn { text, options, metadata }\r\n}"]}